///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////Car tracking project with laser_radar_data_fusion/////////////////////////////////////////
//////////////////////////////////////////////////////////////////////Copyright 2009-10 Akihiro Takeuchi///////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////resize.cpp   resize image (Input and Output must be double-array) ////////////////////////////////////////////

//C++ library
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//ORIGINAL header files
#include "Common.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//definiton of structs and functions//


// struct used for caching interpolation values
struct alphainfo {
	int si, di;
	double alpha;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//sub functions

// copy src into dst using precomputed interpolation values
inline void alphacopy(double *src, double *dst, struct alphainfo *ofs, int n);
// resize along each column
void resize1dtran(double *src, int sheight, double *dst, int dheight, int width, int chan);
//main function
double *resize(double *src,int *sdims,int *odims,double scale);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//sub functions 

// copy src into dst using precomputed interpolation values
inline void alphacopy(double *src, double *dst, struct alphainfo *ofs, int n) 
{
	struct alphainfo *end = ofs + n;
	while (ofs != end) 
	{
		dst[ofs->di] += ofs->alpha * src[ofs->si];
		ofs++;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// resize along each column
// result is transposed, so we can apply it twice for a complete resize
void resize1dtran(double *src, int sheight, double *dst, int dheight, int width, int chan) 
{
	double scale = (double)dheight/(double)sheight;
	double invscale = (double)sheight/(double)dheight; 
	// we cache the interpolation values since they can be 
	// shared among different columns
	int len = (int)(dheight*invscale+0.99) + 2*dheight;
	alphainfo *ofs;
	ofs = (alphainfo*)malloc(sizeof(alphainfo)*len);
	int WD =width*dheight;
	int WS =width*sheight;

	int k = 0;
	for (int dy = 0; dy < dheight; dy++)
	{
		double fsy1 = dy * invscale;
		double fsy2 = fsy1 + invscale;
		int sy1 = (int)(fsy1+0.99);
		int sy2 = (int)fsy2;       
		int dyW = dy*width;

		if (sy1 - fsy1 > 1e-3) {
			ofs[k].di = dyW;
			ofs[k].si = sy1-1;
			ofs[k++].alpha = (sy1 - fsy1) * scale;  
		}
    
		for (int sy = sy1; sy < sy2; sy++) 
		{
			ofs[k].di = dyW;
			ofs[k].si = sy;
			ofs[k++].alpha = scale;
		}

		if (fsy2 - sy2 > 1e-3) 
		{
			ofs[k].di = dyW;
			ofs[k].si = sy2;
			ofs[k++].alpha = (fsy2 - sy2) * scale;
		}
	}
	// resize each column of each color channel
	memset(dst,0, chan*WD*sizeof(double));
	for (int c = 0; c < chan; c++) 
	{
		int CWS = c*WS;
		int CWD = c*WD;
		double *s = src + CWS;	
		double *d = dst + CWD;
		for (int x = 0; x < width; x++) {     
			alphacopy(s, d, ofs, k);
			s+=sheight;
			d++;
		}
	}
	s_free(ofs);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// main function (resize)
// takes a double color image and a scaling factor
// returns resized image

double *resize(double *src,int *sdims,int *odims,double scale)
{
  double *dst;
  if(scale==1.0)
    {
      //memcpy_s(odims,sizeof(int)*3,sdims,sizeof(int)*3);  //memcpy_s(コピー先のバッファー,コピー先のバッファーのサイズ,コピー元のバッファー,コピーする文字数)
      memcpy(odims, sdims,sizeof(int)*3);  //memcpy_s(コピー先のバッファー,コピー先のバッファーのサイズ,コピー元のバッファー,コピーする文字数)
      int DL = odims[0]*odims[1]*odims[2];
      dst = (double*)calloc(DL,sizeof(double));
      //memcpy_s(dst,sizeof(double)*DL,src,sizeof(double)*DL);
      memcpy(dst, src,sizeof(double)*DL);
    }
  else
    {
      odims[0] = (int)((double)sdims[0]*scale+0.5);
      odims[1] = (int)((double)sdims[1]*scale+0.5);
      odims[2] = sdims[2];
      dst = (double*)calloc(odims[0]*odims[1]*sdims[2],sizeof(double));
      double *tmp = (double*)calloc(odims[0]*sdims[1]*sdims[2],sizeof(double));
      resize1dtran(src, sdims[0], tmp, odims[0], sdims[1], sdims[2]);
      resize1dtran(tmp, sdims[1], dst, odims[1], odims[0], sdims[2]);
      s_free(tmp);
    }
  return(dst);
}
